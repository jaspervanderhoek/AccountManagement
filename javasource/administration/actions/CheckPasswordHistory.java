// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package administration.actions;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import com.mendix.core.Core;
import com.mendix.core.objectmanagement.member.MendixHashString;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixIdentifier;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

import administration.proxies.AccountPasswordData;
import administration.proxies.PasswordHistory;
import administration.proxies.constants.Constants;

public class CheckPasswordHistory extends CustomJavaAction<java.lang.Boolean>
{
	private IMendixObject __AccountPasswordDataObject;
	private administration.proxies.AccountPasswordData AccountPasswordDataObject;

	public CheckPasswordHistory(IContext context, IMendixObject AccountPasswordDataObject)
	{
		super(context);
		this.__AccountPasswordDataObject = AccountPasswordDataObject;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		this.AccountPasswordDataObject = __AccountPasswordDataObject == null ? null : administration.proxies.AccountPasswordData.initialize(getContext(), __AccountPasswordDataObject);

		// BEGIN USER CODE
		Long numPeriods = (Constants.getNumExpirationPeriodsWithoutPasswordReUse() == null ? 90 : Constants.getNumExpirationPeriodsWithoutPasswordReUse()),
			 expirationDays = (Constants.getPasswordExpirationDays() == null ? 2 : Constants.getPasswordExpirationDays()),
			 totalDays = (numPeriods * expirationDays);
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_YEAR, -totalDays.intValue() );
		
		IMendixIdentifier accountId = this.__AccountPasswordDataObject.getValue(getContext(), AccountPasswordData.MemberNames.AccountPasswordData_Account.toString());
		
		
		String pass = this.AccountPasswordDataObject.getNewPassword();
		IContext context = Core.createSystemContext();
		
		
		List<IMendixObject> result = Core.createXPathQuery("//" + PasswordHistory.entityName + "[" + PasswordHistory.MemberNames.PasswordHistory_Account + "=$accountId][" + PasswordHistory.MemberNames.PasswordSetOn + ">=$date]")
		.setVariable("date", cal.getTimeInMillis()).setVariable("accountId", accountId).addSort(PasswordHistory.MemberNames.PasswordSetOn.toString(), false).execute(context);
		
		_logNode.trace("Checking history for: " + accountId.toLong() + " checking " + result.size() + " password records, Period: " + totalDays + " days");
		
		MendixHashString passwordAttribute;
		boolean passwordsMatch = false;
		for( IMendixObject obj : result ) {
			passwordAttribute = (MendixHashString) obj.getMember(getContext(), PasswordHistory.MemberNames.PasswordHash.toString());
			passwordsMatch = passwordAttribute.verifyValue(context, pass);
			
			if( passwordsMatch ) {
				_logNode.trace("Checking history for: " + accountId.toLong() + ". Found matching password from: " + _format.format((Date) obj.getValue(context, PasswordHistory.MemberNames.PasswordSetOn.toString()) ) );
				break;
			}
		}
		
		//We return if a password is allowed. So return: not(match)
		return !passwordsMatch;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CheckPasswordHistory";
	}

	// BEGIN EXTRA CODE
	private static final ILogNode _logNode = Core.getLogger("CheckPasswordHistory");
	private static final SimpleDateFormat _format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	// END EXTRA CODE
}
